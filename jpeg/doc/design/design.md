# design

## JPEG_ENCODE
- 1. 图像分割
  - 分割成8*8的块（[?]对于非8的倍数的长宽）
  -
- 2. 颜色空间转换RGB->YCbCr
  - [?]对于gray图片
  - 得到3张不同颜色分量的图片
```
//小数形式
R = Y + 1.4075 * (V-128);  
G = Y - 0.3455 * (U-128) - 0.7169*(V-128);  
B = Y + 1.779 * (U-128);  

Y = 0.299*R + 0.587*G + 0.114*B;
U = (B-Y)/1.772;    
V = (R-Y)/1.402;       (U~(-128-127))
//整数形式
R= Y + ((360 * (V - 128))>>8) ;
G= Y - (( ( 88 * (U - 128)  + 184 * (V - 128)) )>>8) ;
B= Y +((455 * (U - 128))>>8) ;

Y = (77*R + 150*G + 29*B)>>8;
U = ((-44*R  - 87*G  + 131*B)>>8) + 128;
V = ((131*R - 110*G - 21*B)>>8) + 128 ;

//https://blog.csdn.net/xiaoyafang123/article/details/82153279
```

- 3. 离散余弦变换
  - 傅里叶变换的另外一种形式
  - 将8*8的小块分别进行二维傅里叶变换DC-AC表 （至此都是可逆过程可逆）
  - 若要实现较高速度，使用loeffler算法进行转化
- 4. 数据量化
  - 对DC-AC表进行量化(根据不同系数得到0的多少，即不同的图片质量)
  - zig-zag 编码
- DC 系数的差分脉冲调制编码 DPCM
- AC 系数的行程长度编码 (RLC)
- 5. 哈弗曼编码
  - 压缩零的数量
  - 对量化后的数据进行编码。根据字符出现的频率高低确定一个编码表，出现频率高的使用短码，频率低的用短码。以此可以减少数据的尺寸
    - 变长且没有标示符。判断数据单元件的间隔是根据编码自身，各个字段首部的几位都不相等
    - 当信号的符号概率是2的负幂次方分布时，压缩率最高；当信号的符号概率相同时，压缩率最低

## JPEG_DECODE
- 读取文件的大体结构
- 读取哈夫曼表数据
- 建立哈夫曼树
- AC,DC系数的解码
- 反量化
- 反Zig-zag编码
- 反离散余弦变换
- YCrCb向RGB转换
