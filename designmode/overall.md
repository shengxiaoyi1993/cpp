# 列举

## 创建型

### 1. 简单工厂

- simple factory 具体的生产者（函数），拓展不便

  

### 2. abstract factory抽象工厂

- 使用多态方法对适应变动的拓展

### 3. builder 生成器模式

- 灵活的某个成员的拓展

### 4. prototype 原型模式

- 通过clone生成新对象

### 5. singleton 单件模式

- 一个类只有一个对象

## 结构型
### 6. adapter适配器模式
- 接口转换

### 7. bridge 桥接模式
- 实现与抽象分离，两者可以独立变化

### 8. composite 组合模式
- 以树形结构组织成“部分-整体”，使单个对象和组合对象具有一致性

### 9. decorator 装饰模式
- 动态添职能

### 10. facade 外观模式
- 为一个子系统的一组接口提供统一外观

### 11. flyweigt 享元模式
- 共享技术控制粒度

### 12. proxy
- 提供代理以控制对对象的访问

## 行为型

### 13. interpreter(解释器)
- 定义语言和解释器，以解释器解释句子中的语言

### 14. templete method 模板方法
- 定义算法骨架，将一些步骤延迟到子类中。不改变结构即可改变算法的过程

### 15. chain of responsibility
- 使多个对象都有机会处理请求，避免耦合关系
- 任务在链中传播直到有一个对象处理

### 16. command 命令行模式
- 将请求封装成对象，从而用不同的请求对客户进行参数化，排队和记录日志，支持可撤销的操作

### 17. itertor
- 提供一种顺序访问聚合对象的各个元素，又不暴露

### 18. mediator 中介模式
- 用一个中介对象封装一系列对象交互，使各个对象不需要显式调用使耦合松散

### 19. momento备忘录模式
- 在不改变封装性前提下，捕获一个对象的内部状态，并在外部保存状态，
### 20. observer 观察者模式
- 对象间一对多的状态，当一个对象的状态发生变化，所有依赖于他的对象都得到通知

### 21. state
- 允许一个对象改变时改变他的行为，看起来似乎改变了他的类

### 22. strategy 策略模式
- 定义一个个算法使他们之间可以替换

### 23. visitors
- 表示一个作用于某个对象各元素的操作，在不改变各元素的前提下定义作用于这些元素的新操作